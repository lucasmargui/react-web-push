# Nome do workflow, aparece na aba Actions do GitHub
name: Pipeline CI/CD

# Dispara o workflow em determinados eventos
on:
  push:                   # Dispara quando houver push
    branches:
      - main              # Quando for na branch main
      - dev               # Quando for na branch dev
      - '*'               # Ou qualquer outra branch

# Define os jobs que ser√£o executados
jobs:
  build-image:
    runs-on: ubuntu-latest   # Define o sistema operacional da m√°quina virtual

    # Outputs do job, podem ser usados por outros jobs se existirem
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}  # Tag da imagem Docker
      image_uri: ${{ steps.build.outputs.image_uri }}  # URI completa da imagem Docker

    # Lista de steps (passos) que ser√£o executados no job
    steps:

      ###############################
      # 1Ô∏è‚É£ Baixar c√≥digo do reposit√≥rio
      - name: Checkout code
        uses: actions/checkout@v5.0.0
        # Baixa todo o c√≥digo do reposit√≥rio para a m√°quina virtual,
        # permitindo que os pr√≥ximos steps acessem os arquivos.

      ###############################
      # 2Ô∏è‚É£ Detectar automaticamente o ambiente (dev, prod ou test)
      - name: Define environment
        id: env                 # D√° um ID para o step, permitindo acessar outputs dele depois
        run: |
          if [[ "${GITHUB_REF_NAME}" == "main" ]]; then
            # Se a branch for main, define ambiente como "prod"
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [[ "${GITHUB_REF_NAME}" == "dev" ]]; then
            # Se a branch for dev, define ambiente como "dev"
            echo "environment=dev" >> $GITHUB_OUTPUT
          else
            # Para qualquer outra branch, define ambiente como "test"
            echo "environment=test" >> $GITHUB_OUTPUT
          fi
        # $GITHUB_OUTPUT √© um arquivo especial do GitHub Actions que armazena
        # outputs do step. Aqui estamos criando um output chamado "environment",
        # que ser√° acess√≠vel por steps futuros como:
        # ${{ steps.env.outputs.environment }}

      ######################### CREDENTIALS #############################
      # Debug de vari√°veis de ambiente / segredos
      - name: Debug env
        run: |
          # Mostra se as credenciais do Docker Hub est√£o vazias
          # N√£o imprime os valores reais por seguran√ßa
          echo "USER empty? -> ${{ secrets.DOCKERHUB_USERNAME == '' }}"
          echo "TOKEN empty? -> ${{ secrets.DOCKERHUB_TOKEN == '' }}"

      # Login no Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}  # Usu√°rio do Docker Hub (secreto)
          password: ${{ secrets.DOCKERHUB_TOKEN }}     # Token do Docker Hub (secreto)
        # Isso autentica o runner para permitir enviar imagens Docker

      ###############################
      # 3Ô∏è‚É£ Build + Push da imagem Docker
      - name: Build, tag, and push docker image to Docker Hub
        id: build      # Define ID para o step, necess√°rio para criar outputs
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USERNAME }}  # Usu√°rio Docker
          REPOSITORY: react-web-push                        # Nome do reposit√≥rio Docker
          ENVIRONMENT: ${{ steps.env.outputs.environment }}   # Ambiente detectado no step anterior

        run: |
          # Pega os primeiros 7 caracteres do SHA do commit atual
          COMMIT_SHA=$(echo $GITHUB_SHA | cut -c1-7)

          # Cria uma tag √∫nica para a imagem, combinando ambiente + commit
          IMAGE_TAG=${ENVIRONMENT}-${COMMIT_SHA}

          # Monta a URI completa da imagem Docker
          IMAGE_URI=docker.io/$DOCKERHUB_USER/$REPOSITORY:$IMAGE_TAG

          echo "üî® Build da imagem..."
          docker build -t $IMAGE_URI .   # Constr√≥i a imagem usando o Dockerfile da raiz

          echo "‚¨ÜÔ∏è Pushing..."
          docker push $IMAGE_URI         # Envia a imagem para o Docker Hub

          # Cria outputs do step, que podem ser acessados depois como:
          # steps.build.outputs.image_tag / image_uri
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT

      ###############################
      # 4Ô∏è‚É£ Print final / Informa√ß√µes de deploy
      - name: Deployment Info
        run: |
          echo "Imagem enviada!"
          echo "Tag: ${{ steps.build.outputs.image_tag }}"  # Mostra a tag da imagem
          echo "URI: ${{ steps.build.outputs.image_uri }}"  # Mostra a URI completa da imagem

  deploy-ssh:
    runs-on: ubuntu-latest
    needs: build-image
    steps:
      - name: Deploy to VPS via SSH
        env:
          DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          REPOSITORY: environment_test
          IMAGE_TAG: ${{ needs.build-image.outputs.image_tag }}
          INSTANCE_KEY: ${{ secrets.INSTANCE_KEY }}
          ELASTIC_IP: ${{ secrets.ELASTIC_IP }}
          DOMAIN: ${{ secrets.DOMAIN }}
          CONTAINER_NAME: site
        run: |
          echo "$INSTANCE_KEY" | tr -d '\r' > key.pem
          chmod 400 key.pem

          ssh -i key.pem -o StrictHostKeyChecking=no ubuntu@$ELASTIC_IP << EOF
            export DOCKERHUB_USER="$DOCKERHUB_USER"
            export REPOSITORY="$REPOSITORY"
            export IMAGE_TAG="$IMAGE_TAG"
            export ELASTIC_IP="$ELASTIC_IP"
            export DOMAIN="$DOMAIN"
            export CONTAINER_NAME="$CONTAINER_NAME"

            echo "Atualizando sistema..."
            sudo apt update  
            sudo apt upgrade -y

            echo "Instalando depend√™ncias..."
            sudo apt install -y curl


            if command -v docker >/dev/null 2>&1; then
                echo "Docker j√° est√° instalado. Pulando instala√ß√£o."
            else
                echo "Docker n√£o encontrado. Instalando..."
                curl -fsSL https://get.docker.com -o /root/get-docker.sh
                sh /root/get-docker.sh
            fi

            echo "Baixando CertBot"
            sudo docker pull certbot/certbot:latest 

            echo "Parando containers Docker na porta 80"
            CONTAINERS_PORT80=$(sudo docker ps -q --filter publish=80)
            if [ ! -z "$CONTAINERS_PORT80" ]; then
              sudo docker stop $CONTAINERS_PORT80 || true
              sudo docker rm $CONTAINERS_PORT80 || true
            else
              echo "Nenhum container Docker na porta 80."
            fi

            echo "Parando qualquer processo no host usando porta 80"
            PORT80_PID=$(sudo lsof -t -i:80)
            if [ ! -z "$PORT80_PID" ]; then
              echo "Matando processo na porta 80 (PID: $PORT80_PID)"
              sudo kill -9 $PORT80_PID || true
            else
              echo "Nenhum processo usando porta 80."
            fi

            sudo systemctl stop nginx
            sudo systemctl disable nginx

            echo "Baixando certtificado ssl"
            sudo docker run --rm -p 80:80 -v /etc/letsencrypt:/etc/letsencrypt -v /var/lib/letsencrypt:/var/lib/letsencrypt certbot/certbot:latest certonly --standalone --non-interactive --agree-tos --force-renewal --email lucasmartinsgui@outlook.com -d $DOMAIN -d www.$DOMAIN
          EOF

          rm key.pem